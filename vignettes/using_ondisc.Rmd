---
title: "Using ondisc"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using ondisc}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE
)
```

This vignette runs through an example of using the `ondisc` package. First, we download an example single-cell dataset from 10X Genomics. Next, we store the data in an `on_disc_matrix`, the core object provided by `ondisc`. Finally, we perform some simple operations on the initialized `on_disc_matrix`, including subset, pull sub-matrix into memory, and compute summary statistics. Let's load the required packages for this vignette.

```{r, message=FALSE}
library(R.utils)
library(ondisc)
```

We work with the public [PBMC dataset](https://support.10xgenomics.com/single-cell-gene-expression/datasets/4.0.0/Parent_NGSC3_DI_PBMC) published by 10X Genomics. We download the `matrix.mtx`, `barcodes.tsv`, and `features.tsv` files from the 10X website into a specified directory, `data_dir`. The files are 88 MB in total, so the download should not take too long. Be sure to change the file path of `data_dir` to a location on your machine.

```{r, eval=FALSE}
data_dir <- "/Users/timbarry/Box/onDisc_all/onDisc_offsite/raw_data" # change this file path!
download.file(url = "https://cf.10xgenomics.com/samples/cell-exp/4.0.0/Parent_NGSC3_DI_PBMC/Parent_NGSC3_DI_PBMC_filtered_feature_bc_matrix.tar.gz", destfile = paste0(data_dir, "/pbmc.tar.gz"))
fs <- paste0("filtered_feature_bc_matrix/", c("features.tsv.gz", "matrix.mtx.gz", "barcodes.tsv.gz"))
untar(tarfile = paste0(data_dir, "/pbmc.tar.gz"), files = fs, exdir = data_dir)
for (curr_f in fs) gunzip(paste0(data_dir, "/", curr_f))
```

If the above code chunk worked, then the downloaded files are unzipped and stored in the subdirectory `filtered_feature_bc_matrix`. Let's list the files now and save the file paths to variables.

```{r, eval=FALSE}
data_sub_dir <- paste0(data_dir, "/filtered_feature_bc_matrix")
list.files(data_sub_dir)
mtx_fp <- paste0(data_sub_dir, "/matrix.mtx")
barcode_fp <- paste0(data_sub_dir, "/barcodes.tsv")
features_fp <- paste0(data_sub_dir, "/features.tsv")
```

```{r, include=FALSE}
# execute this in the absence of evaluating the above two chunks.
data_dir <- "/Users/timbarry/Box/onDisc_all/onDisc_offsite/raw_data" # change this file path!
data_sub_dir <- paste0(data_dir, "/filtered_feature_bc_matrix")
mtx_fp <- paste0(data_sub_dir, "/matrix.mtx")
barcode_fp <- paste0(data_sub_dir, "/barcodes.tsv")
features_fp <- paste0(data_sub_dir, "/features.tsv")
expression_matrix <- on_disc_matrix(h5_file = paste0(data_sub_dir, "/on_disc_matrix_1.h5"))
```

If you would like to use a small, example dataset that ships with the package instead of the 10X PBMC data, execute the following chunk. 

```{r}
if (FALSE) { # change to TRUE if you instead would like to use a small, pre-packaged dataset!
  data_sub_dir <- paste0(find.package(package = "ondisc"), "/extdata")
  list.files(data_sub_dir)
  mtx_fp <- paste0(data_sub_dir, "/matrix_1.mtx")
  barcode_fp <- paste0(data_sub_dir, "/barcodes_1.tsv")
  features_fp <- paste0(data_sub_dir, "/features_1.tsv")
}
```

## Initialize an `on_disc_matrix`

Next, we initialize an `on_disc_matrix` that will contain the expression data. An `on_disc_matrix` is the core object implemented by `ondisc`; its purpose is to store a gene-by-cell expression matrix on-disk rather than in-memory, facilitating large-scale computations on expression matrices. We initialize an `on_disc_matrix` from a `.mtx` file using the function `create_on_disc_matrix_from_10x_mtx`. We pass the file paths of `matrix.mtx`, `barcodes.tsv`, and `features.tsv` as arguments to the function, as well as the on-disk directory in which we would like to store the expression data.

```{r, eval=FALSE}
on_disc_dir <- data_sub_dir
expression_matrix <- create_on_disc_matrix_from_10x_mtx(mtx_fp = mtx_fp, barcode_fp = barcode_fp, features_fp = features_fp, on_disc_dir = on_disc_dir)
```

The function `create_on_disc_matrix_from_10x_mtx` reads the expression data from the `.mtx` and `.tsv` files, manipulates the data, and then stores the data in a specially-formatted HDF5 file named `on_disc_matrix_1.h5`. (If there already exists a file named `on_disc_matrix_1.h5` in the specified directory, then `create_on_disc_matrix_from_10x_mtx` instead stores the expression data in a file called `on_disc_matrix_2.h5`, and so on.) `create_on_disc_matrix_from_10x_mtx` returns an R object of class `on_disc_matrix`, which in the above example, we save to the variable `expression_matrix`. An `on_disc_matrix` is an S4 object that contains three slots: a path to the on-disk HDF5 file that stores the expression data, an integer vector storing the cells currently in use, and an integer vector storing the genes currently in use. Thus, `on_disc_matrix` objects typically have quite a small memory footprint (in this example, only about 1.2 KB or 1200 bytes). 

```{r}
str(expression_matrix)
object.size(expression_matrix)
```

The algorithm underlying `create_on_disc_matrix_from_10x_mtx` is highly efficient. However, `on_disc_matrices` are stored as HDF5 files under the hood, and because HDF5 does not currently support multithreaded write, `create_on_disc_matrix_from_10x_mtx` is in practice slower than one might expect. The code in the above chunk takes about fifteen minutes to run on the real data and a few seconds to run on the in-package example data. However, `create_on_disc_matrix_from_10x_mtx` only needs to be run once per dataset, even after closing and starting new R sessions. Additionally, the designers of HDF5 are [considering](https://forum.hdfgroup.org/t/multi-threading-in-the-hdf5-library/6462) implementing multithreaded read and write. `create_on_disc_matrix_from_10x_mtx` will become faster if and when this feature becomes available.

It is also possible to initialize an `on_disc_matrix` from an .h5 file or an in-memory R matrix. See the article XXX.

## Obtain basic information from an `on_disc_matrix`

The newly-created variable `expression_matrix` is an object of class `on_disc_matrix`. Evaluating `expression_matrix` in the console prints its class, as well as the number of genes and cells in the matrix.

```{r}
expression_matrix
```

Calling `head` prints the expressions of the first few genes and cells.
```{r}
head(expression_matrix)
```

The functions `get_gene_ids`, `get_gene_names`, and `get_cell_barcodes` return the gene IDs, (human-readable) gene names, and cell barcodes, respectively.

```{r}
gene_ids <- get_gene_ids(expression_matrix)
gene_ids[1:5]
gene_names <- get_gene_names(expression_matrix)
gene_names[1:5]
cell_barcodes <- get_cell_barcodes(expression_matrix)
cell_barcodes[1:5]
```

Finally, `dim`, `nrow`, and `ncol` return the dimension, number of rows (i.e., number of genes), and number of columns (i.e., number of cells) of the expression matrix.
```{r}
dim(expression_matrix)
nrow(expression_matrix)
ncol(expression_matrix)
```

## Subset

We can subset an `on_disc_matrix` to obtain a new `on_disc_matrix` that is a submatrix of the original. Subsetting `on_disc_matrices` is very similar to subsetting normal R matrices. We use single square brackets and specify the rows and columns that we would like to keep by integer position.

```{r}
x <- expression_matrix[100:110,] # keep genes 100-110
x <- expression_matrix[,-c(10,20)] # keep all cells except cells 10 and 20
x <- expression_matrix[c(1:100, 200:250), 300:500] # keep genes 1-100, 200-250 and cells 300-500
x # x has class on_disc_matrix, just like expression_matrix
```

We also can subset `on_disc_matrices` using logical or character vectors. Character vectors correspond to *gene ID* and *cell barcode*, respectively.

```{r}
x <- expression_matrix[c("ENSG00000260528", "ENSG00000258908", "ENSG00000081913"),] # keep these three genes
x <- expression_matrix[,c("ACAGCCGCAGAAACCG", "CTACTATAGTGTACCT")] # keep these two cells
x <- expression_matrix[!(get_gene_ids(expression_matrix) %in% c("ENSG00000167525", "ENSG00000235815")),] # keep all genes except ENSG00000167525 and ENSG00000235815
```

Subsetting an `on_disc_matrix` leaves the original object unchanged.
```{r}
expression_matrix # unchanged
```
This important property, called *object persistence*, makes programming with `on_disc_matrices` easier and more intuitive.

## Pull submatrix into memory

We can pull submatrices of an `on_disc_matrix` into memory, allowing us to perform operations on subsets of the data, like regressing on a subset of genes or examining the distribution of a subset of cells. To pull a submatrix into memory, specify the genes and/or cells to extract using *double* (as opposed to *single*) square brackets.

```{r}
m <- expression_matrix[[6, ]] # pull gene 6 into memory
m <- expression_matrix[[,100]] # pull cell 100 into memory
m <- expression_matrix[[100:110, 200:250]] # pull genes 100-110 and cells 200-250 into memory
```

The output of a double-bracket "pull into-memory" operation is a sparse matrix, implemented by the package `Matrix`. `Matrix` provides many useful functions for working with sparse matrices, in addition to all the standard matrix operations.

```{r}
class(m) # m is of class Matrix
```

Like with subsetting, we can pull submatrices into memory using a character vector or logical vector instead of a numeric vector.

```{r}
m <- expression_matrix[[c("ENSG00000260528", "ENSG00000258908", "ENSG00000081913"),]] # pull genes ENSG00000260528, ENSG00000258908, and ENSG00000081913 into memory
m <- expression_matrix[[,c("ACAGCCGCAGAAACCG", "CTACTATAGTGTACCT")]] # pull cells ACAGCCGCAGAAACCG and CTACTATAGTGTACCT into memory
```

Recall that, when working with lists, single brackets return a subsetted list and double brackets return an object stored *inside* the list. The principle is similar for `on_disc_matrices`: single brackets return a subsetted `on_disc_matrix`, and double brackets return a sparse in-memory matrix.

## Operate on an entire `on_disc_matrix`

A common step in many single-cell analysis pipelines is to compute cell-wise and gene-wise summary statistics. The function `summarize_expression_matrix` takes an `on_disc_matrix` as an argument and returns some useful cell-wise summary statistics (namely, total UMI count per cell, total number of genes expressed per cell, and percentage of UMIs that are mitochondrial per cell) and gene-wise summary statistics (namely, total UMI count per gene and total number of cells in which gene is expressed). The function works by partitioning the expression data into chunks, loading each chunk into memory, computing the relevant summary statistics for each chunk, and combining the results across chunks. `summarize_expression_matrix` takes about thirty seconds to run on the real data and about a second to run on the in-package example data. The running time of `summarize_expression_matrix` is longer than that of other functions because `summarize_expression_matrix` must load the entire dataset into memory (piece-by-piece).

```{r}
covariate_matrices <- summarize_expression_matrix(expression_matrix)
cell_covariate_matrix <- covariate_matrices$cell_covariate_matrix
gene_covariate_matrix <- covariate_matrices$gene_covariate_matrix
head(cell_covariate_matrix)
head(gene_covariate_matrix)
```
We can use `apply` to apply more general functions to the rows and columns on an `on_disc_matrix`. Below, we use `apply` to calculate the standard deviation and mean of each gene's expression.

```{r}
gene_means_and_sds <- apply(X = expression_matrix, MARGIN = 1, FUN = function(r) c(mean = mean(r), sd = sd(r)))
```

`summarize_expression_matrix` is much faster than the equivalent calls to `apply`. Thus, to obtain basic cell-wise and gene-wise summary statistics, it is best to use `summarize_expression_matrix`.

## Saving and loading `on_disc_matrices`

It is important to remember that there are two components to an `on_disc_matrix`: the `.h5` file stored on disk, and the `on_disc_matrix` R object stored in memory. The latter contains a file path to the former, allowing users to interact with the on-disk data from within R.

To save an `on_disc_matrix`, we simply use `saveRDS` to write the `on_disc_matrix` R object to an `.rds` file.

```{r}
saveRDS(object = expression_matrix, file = paste0(data_sub_dir, "/expression_matrix.rds"))
rm(expression_matrix)
```

We can then load the `on_disc_matrix` by calling `readRDS` on the `.rds` file.

```{r}
expression_matrix <- readRDS(file = paste0(data_sub_dir, "/expression_matrix.rds"))
```

Suppose we forget to save the `on_disc_matrix` R object that we initialized through a call to `create_on_disc_matrix_from_10x_mtx`. We can use the function `on_disc_matrix` (i.e., the constructor of the  `on_disc_matrix` class) to create a new `on_disc_matrix` by specifying the file path of the corresponding on-disk `.h5` file.

```{r}
rm(expression_matrix)
expression_matrix <- on_disc_matrix(h5_file = paste0(data_sub_dir, "/on_disc_matrix_1.h5"))
```

You should not call `create_on_disc_matrix_from_10x_mtx` more than once on the same raw expression data; doing so is wasteful.

## Connecting to `Seurat`

`Seurat` is a popular R package for analyzing single-cell data in memory. We can convert an `on_disc_matrix` object to a `Seurat` object using the function `convert_to_seurat_object`. Because the data contained in an `on_disc_matrix` might not fit entirely into memory, it is often a good idea to first subset the `on_disc_matrix` before calling `convert_to_seurat_object`. Below, we define a new `on_disc_matrix` `x` that is a subset of `expression_matrix`. Then, we call `convert_to_seurat_object` on `x`.

```{r}
x <- expression_matrix[1:100, -(300:399)]
seurat_obj <- convert_to_seurat_object(x = x)
seurat_obj
```
