% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/high_level_initialize.R
\name{create_ondisc_matrix_from_mtx}
\alias{create_ondisc_matrix_from_mtx}
\title{Create an \code{ondisc_matrix} from a .mtx file.}
\usage{
create_ondisc_matrix_from_mtx(
  mtx_fp,
  barcodes_fp,
  features_fp,
  odm_fp,
  metadata_fp = NULL,
  n_lines_per_chunk = 3e+08,
  progress = TRUE
)
}
\arguments{
\item{mtx_fp}{file path to a .mtx file storing the expression data. The .mtx file can represent either an integer matrix or a logical (i.e., binary) matrix. If the .mtx file contains only two columns (after the initial three-column row of metadata), then the .mtx file is assumed to represent a logical matrix.}

\item{barcodes_fp}{file path to the .tsv file containing the cell barcodes.}

\item{features_fp}{file path to the features.tsv file. The first column (required) contains the feature IDs (e.g., ENSG00000186092), and the second column (optional) contains the human-readable feature names (e.g., OR4F5). Subsequent columns are discarded.}

\item{odm_fp}{location to write the ondisc matrix to disk}

\item{metadata_fp}{location to write the me metadata .RDS file. By default, a file called "metadata.rds" stored in the same directory as the backing .odm file.}

\item{n_lines_per_chunk}{(optional) number of lines in .mtx file to process per chunk. Defaults to 3e+08.}

\item{progress}{(optional; default FALSE) print progress messages?}
}
\value{
A list containing (i) an ondisc_matrix, (ii) a cell-specific covariate matrix, and (iii) a feature-specific covariate matrix; if the parameter return_metadata_ondisc_matrix set to TRUE, converts the list to a metadata_ondisc_matrix before returning.
}
\description{
Initializes an \code{ondisc_matrix} from a .mtx file, a features.tsv file, and a barcodes.tsv file. Returns an \code{ondisc_matrix} along with cell-specific and feature-specific covariate matrices.
}
\details{
The function can compute the following cell-specific and feature-specific covariates:
\itemize{
\item cell-specific: (i) total number of features expressed in cell (n_nonzero_cell), (ii) total UMI count (n_umis_cell), and (iii) percentage of UMIs that map to mitochondrial genes (p_mito_cell).
\item feature-specific: (i) total number of cells in which feature is expressed (n_nonzero_feature), (ii) mean expression of feature across cells (mean_expression_feature), (iii) coefficient of variation of feature expression across cells (coef_of_variation_feature).
}

The function decides which covariates to compute given the input; in general, the function computes the maximum set of covariates possible.
}
\examples{
# First example: initialize a metadata_ondisc_matrix
# using simulated expression data; store output in tempdir()
tempfile <- create_new_directory()
odm_fp <- paste0(tempfile, "/expression_odm")
file_locs <- system.file("extdata",package = "ondisc",
c("gene_expression.mtx", "genes.tsv", "cell_barcodes.tsv"))
names(file_locs) <- c("expressions", "features", "barcodes")
expression_data <- create_ondisc_matrix_from_mtx(mtx_fp = file_locs[["expressions"]],
barcodes_fp = file_locs[["barcodes"]],
features_fp = file_locs[["features"]],
odm_fp = odm_fp)

# Second example: initialize a metadata_ondisc_matrix using simulated
# gRNA perturbation data; store in tempdir()
tempfile <- create_new_directory()
odm_fp <- paste0(tempfile, "/expression_odm")
file_locs <- system.file("extdata", package = "ondisc",
c("perturbation.mtx", "guides.tsv", "cell_barcodes.tsv"))
names(file_locs) <- c("perturbations", "features", "barcodes")
perturbation_data <- create_ondisc_matrix_from_mtx(mtx_fp = file_locs[["perturbations"]],
barcodes_fp = file_locs[["barcodes"]],
features_fp = file_locs[["features"]],
odm_fp = odm_fp)


# Third example: initialize from a list of .mtx files
tempfile <- create_new_directory()
odm_fp <- paste0(tempfile, "/expression_odm")
n_mat <- 5
n_row_multi <- 300
n_col_multi <- sample(x = seq(100, 300), size = n_mat, replace = TRUE)
col_multi_cumsum <- c(0,cumsum(n_col_multi))
logical_mat_multi <- vector(mode = "logical", length = n_mat)
#' generate the matrices using create_synthetic_data
r_mats_plus_data_multi <- vector(mode = "list", length = n_mat)
set.seed(1)
for (i in seq(1,n_mat)) {
  r_mats_plus_data_multi[[i]] <- create_synthetic_data(n_row = n_row_multi,
                                                       n_col = n_col_multi[i],
                                                       logical_mat = logical_mat_multi[i])
  r_mats_plus_data_multi[[i]]$features_df <- r_mats_plus_data_multi[[1]]$features_df
  r_mats_plus_data_multi[[i]]$features_fp <- r_mats_plus_data_multi[[1]]$features_fp
}
mtx_fp <- sapply(X = r_mats_plus_data_multi, function(i) i$matrix_fp)
barcodes_fp <- sapply(X = r_mats_plus_data_multi, function(i) i$barcodes_fp)
features_fp <- r_mats_plus_data_multi[[1]]$features_fp
odm <- create_ondisc_matrix_from_mtx(mtx_fp, barcodes_fp, features_fp, odm_fp)
}
